import{g as i,J as C,d as y,c as v}from"./main-voVUH4hk.js";const h={async getAll(e={}){try{return(await i.get("people/",{params:e})).data}catch(a){throw a}},async getById(e){try{return(await i.get(`people/${e}/`)).data}catch(a){throw a}},async create(e){try{return(await i.post("people/",e)).data}catch(a){throw a}},async update(e,a){try{return(await i.put(`people/${e}/`,a)).data}catch(c){throw c}},async partialUpdate(e,a){try{return(await i.patch(`people/${e}/`,a)).data}catch(c){throw c}},async delete(e){try{return(await i.delete(`people/${e}/`)).data}catch(a){throw a}}},N=C("people",()=>{const e=y([]),a=y(!1),c=y(null),f=y(null),o=y(null),m=300*1e3,E=v(()=>a.value),I=v(()=>!!c.value),x=v(()=>e.value.length),F=v(()=>e.value),g=v(()=>t=>e.value.find(r=>r.id===t)),w=v(()=>f.value?new Date().getTime()-f.value<m:!1),u=()=>{c.value=null},l=t=>{a.value=t},p=t=>{c.value=t,a.value=!1},P=async(t=!1)=>{if(!t&&w.value&&e.value.length>0)return e.value;l(!0),u();try{const r=await h.getAll();return e.value=r.results||r,f.value=new Date().getTime(),e.value}catch(r){throw console.error("Error fetching people:",r),p(r.response?.data?.message||"Failed to load people"),r}finally{l(!1)}};return{people:e,loading:a,error:c,selectedPerson:o,isLoading:E,hasError:I,peopleCount:x,getPeopleList:F,getPersonById:g,isCacheValid:w,clearError:u,fetchPeople:P,fetchPersonById:async(t,r=!1)=>{const s=g.value(t);if(!r&&s&&w.value)return o.value=s,s;l(!0),u();try{const n=await h.getById(t),d=e.value.findIndex(S=>S.id===t);return d!==-1?e.value[d]=n:e.value.push(n),o.value=n,f.value=new Date().getTime(),n}catch(n){throw console.error("Error fetching person:",n),p(n.response?.data?.message||"Failed to load person"),n}finally{l(!1)}},createPerson:async t=>{l(!0),u();try{const r=await h.create(t);return e.value.unshift(r),o.value=r,r}catch(r){throw console.error("Error creating person:",r),p(r.response?.data?.message||"Failed to create person"),r}finally{l(!1)}},updatePerson:async(t,r)=>{l(!0),u();try{const s=await h.update(t,r),n=e.value.findIndex(d=>d.id===t);return n!==-1&&(e.value[n]=s),o.value?.id===t&&(o.value=s),s}catch(s){throw console.error("Error updating person:",s),p(s.response?.data?.message||"Failed to update person"),s}finally{l(!1)}},patchPerson:async(t,r)=>{l(!0),u();try{const s=await h.partialUpdate(t,r),n=e.value.findIndex(d=>d.id===t);return n!==-1&&(e.value[n]=s),o.value?.id===t&&(o.value=s),s}catch(s){throw console.error("Error updating person:",s),p(s.response?.data?.message||"Failed to update person"),s}finally{l(!1)}},deletePerson:async t=>{l(!0),u();try{return await h.delete(t),e.value=e.value.filter(r=>r.id!==t),o.value?.id===t&&(o.value=null),!0}catch(r){throw console.error("Error deleting person:",r),p(r.response?.data?.message||"Failed to delete person"),r}finally{l(!1)}},clearSelectedPerson:()=>{o.value=null},refreshCache:async()=>await P(!0),clearStore:()=>{e.value=[],o.value=null,c.value=null,a.value=!1,f.value=null}}});export{N as u};
